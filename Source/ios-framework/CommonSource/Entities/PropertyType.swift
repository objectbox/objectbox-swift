/*
 * Copyright 2020 ObjectBox Ltd. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all



///  Basic type of a property
public enum PropertyType: UInt16 {
    public typealias T = UInt16
    public static var byteSize: Int { return MemoryLayout<UInt16>.size }
    public var value: UInt16 { return self.rawValue }
    ///  Not a real type, just best practice (e.g. forward compatibility)
    case unknown = 0
    case bool = 1
    case byte = 2
    case short = 3
    case char = 4
    case int = 5
    case long = 6
    case float = 7
    case double = 8
    case string = 9
    ///  Date/time stored as a 64 bit long representing milliseconds since 1970-01-01 (unix epoch)
    case date = 10
    ///  Relation to another entity
    case relation = 11
    ///  High precision date/time stored as a 64 bit long representing nanoseconds since 1970-01-01 (unix epoch)
    case dateNano = 12
    case flex = 13
    case reserved3 = 14
    case reserved4 = 15
    case reserved5 = 16
    case reserved6 = 17
    case reserved7 = 18
    case reserved8 = 19
    case reserved9 = 20
    case reserved10 = 21
    case boolVector = 22
    case byteVector = 23
    case shortVector = 24
    case charVector = 25
    case intVector = 26
    case longVector = 27
    case floatVector = 28
    case doubleVector = 29
    case stringVector = 30
    case dateVector = 31
    case dateNanoVector = 32

    public static var max: PropertyType { return .dateNanoVector }
    public static var min: PropertyType { return .unknown }
}

/// External property types for integration with external systems (e.g., other databases).
/// Numeric values start at 100 to avoid overlaps with ObjectBox's PropertyType.
public enum ExternalPropertyType: UInt16 {
    /// Not a real type: represents uninitialized state and can be used for forward compatibility.
    case unknown = 0
    /// Representing type: ByteVector
    /// Encoding: 1:1 binary representation, little endian (16 bytes)
    case int128 = 100
    case reserved1 = 101
    /// UUID (Universally Unique Identifier) as defined by RFC 9562.
    /// ObjectBox uses the UUIDv7 scheme (timestamp + random) to create new UUIDs.
    /// UUIDv7 is a good choice for database keys as it's mostly sequential and encodes a timestamp.
    /// However, if keys are used externally, consider UuidV4 for better privacy by not exposing any time information.
    /// Representing type: ByteVector
    /// Encoding: 1:1 binary representation (16 bytes)
    case uuid = 102
    /// IEEE 754 decimal128 type, e.g., supported by MongoDB.
    /// Representing type: ByteVector
    /// Encoding: 1:1 binary representation (16 bytes)
    case decimal128 = 103
    /// UUID represented as a string of 36 characters, e.g., "019571b4-80e3-7516-a5c1-5f1053d23fff".
    /// For efficient storage, consider the Uuid type instead, which occupies only 16 bytes (20 bytes less).
    /// This type may still be a convenient alternative as the string type is widely supported and more human-readable.
    /// In accordance with standards, new UUIDs generated by ObjectBox use lowercase hexadecimal digits.
    /// Representing type: String
    case uuidString = 104
    /// UUID (Universally Unique Identifier) as defined by RFC 9562.
    /// ObjectBox uses the UUIDv4 scheme (completely random) to create new UUIDs.
    /// Representing type: ByteVector
    /// Encoding: 1:1 binary representation (16 bytes)
    case uuidV4 = 105
    /// Like UuidString, but using the UUIDv4 scheme (completely random) to create new UUID.
    /// Representing type: String
    case uuidV4String = 106
    /// Key/value map; e.g., corresponds to a JSON object or a MongoDB document (although not keeping the key order).
    /// Unlike the Flex type, this must contain a map value (e.g., not a vector or a scalar).
    /// Representing type: Flex
    /// Encoding: Flex
    case flexMap = 107
    /// A vector (aka list or array) of flexible elements; e.g., corresponds to a JSON array or a MongoDB array.
    /// Unlike the Flex type, this must contain a vector value (e.g., not a map or a scalar).
    /// Representing type: Flex
    /// Encoding: Flex
    case flexVector = 108
    /// Placeholder (not yet used) for a JSON document.
    /// Representing type: String
    case json = 109
    /// Placeholder (not yet used) for a BSON document.
    /// Representing type: ByteVector
    case bson = 110
    /// JavaScript source code.
    /// Representing type: String
    case javaScript = 111
    /// A JSON string that is converted to a native representation in the external system.
    /// For example, a JSON object on the ObjectBox side (string) would be converted to an embedded document in MongoDB.
    /// It depends on the external system what kind of JSON structures are supported.
    /// For MongoDB, this is very flexible and allows (nested) objects, arrays, primitives, etc.
    /// Representing type: String
    case jsonToNative = 112
    case reserved6 = 113
    case reserved7 = 114
    case reserved8 = 115
    /// A vector (array) of Int128 values.
    case int128Vector = 116
    case reserved9 = 117
    /// A vector (array) of Uuid values.
    case uuidVector = 118
    case reserved10 = 119
    case reserved11 = 120
    case reserved12 = 121
    case reserved13 = 122
    /// The 12-byte ObjectId type in MongoDB.
    /// Representing type: ByteVector
    /// Encoding: 1:1 binary representation (12 bytes)
    case mongoId = 123
    /// A vector (array) of MongoId values.
    case mongoIdVector = 124
    /// Representing type: Long
    /// Encoding: Two unsigned 32-bit integers merged into a 64-bit integer.
    case mongoTimestamp = 125
    /// Representing type: ByteVector
    /// Encoding: 3 zero bytes (reserved, functions as padding), fourth byte is the sub-type,
    /// followed by the binary data.
    case mongoBinary = 126
    /// Representing type: string vector with 2 elements (index 0: pattern, index 1: options).
    /// Encoding: 1:1 string representation.
    case mongoRegex = 127

    public static var max: ExternalPropertyType { return .mongoRegex }
    public static var min: ExternalPropertyType { return .unknown }
}

///  Bit-flags defining the behavior of properties.
///  Note: Numbers indicate the bit position
public enum PropertyFlags: UInt32 {
    public typealias T = UInt32
    public static var byteSize: Int { return MemoryLayout<UInt32>.size }
    public var value: UInt32 { return self.rawValue }
    ///  64 bit long property (internally unsigned) representing the ID of the entity.
    ///  May be combined with: NON_PRIMITIVE_TYPE, ID_MONOTONIC_SEQUENCE, ID_SELF_ASSIGNABLE.
    case id = 1
    ///  On languages like Java, a non-primitive type is used (aka wrapper types, allowing null)
    case nonPrimitiveType = 2
    ///  Unused yet
    case notNull = 4
    case indexed = 8
    ///  Unused yet
    case reserved = 16
    ///  Unique index
    case unique = 32
    ///  Unused yet: Use a persisted sequence to enforce ID to rise monotonic (no ID reuse)
    case idMonotonicSequence = 64
    ///  Allow IDs to be assigned by the developer
    case idSelfAssignable = 128
    ///  Unused yet
    case indexPartialSkipNull = 256
    ///  Unused yet in user land.
    ///  Used internally by relations for 1) backlinks and 2) to clear references to deleted objects (required for ID reuse).
    case indexPartialSkipZero = 512
    ///  Virtual properties may not have a dedicated field in their entity class, e.g. target IDs of to-one relations
    case virtual = 1024
    ///  Index uses a 32 bit hash instead of the value. 32 bit is the default hash size because:
    ///  they take less disk space, run well on 32 bit systems, and also run quite well on 64 bit systems
    ///  (especially for small to medium sized values).
    ///  and should be OK even with a few collisions.
    case indexHash = 2048
    ///  Index uses a 64 bit hash instead of the value.
    ///  Recommended mostly for 64 bit machines with values longer than 200 bytes;
    ///  small values are faster with a 32 bit hash even on 64 bit machines.
    case indexHash64 = 4096
    ///  Unused yet: While our default are signed ints, queries and indexes need do know signing info.
    ///  Note: Don't combine with ID (IDs are always unsigned internally).
    case unsigned = 8192
    ///  By defining an ID companion property, a special ID encoding scheme is activated involving this property.
    /// 
    ///  For Time Series IDs, a companion property of type Date or DateNano represents the exact timestamp.
    ///  (In the future, ID companion string properties may be added as another supported type).
    case idCompanion = 16384

    /// Unique on-conflict strategy: the object being put replaces any existing conflicting object (deletes it).
    case uniqueOnConflictReplace = 32768

    public static var min: PropertyFlags { return .id }
    public static var max: PropertyFlags { return .uniqueOnConflictReplace }
}


extension Array where Element == PropertyFlags {
    var rawValue: UInt32 {
        var combined: UInt32 = 0
        for value in self {
            combined |= value.rawValue
        }
        return combined
    }
}
